<resources>
    <string name="app_name">MaTricks</string>
    <string name="TapButton">Tap Anywhere to Continue</string>
    <string name="Transpose_code">
        
#include&lt;iostream&gt;\n
\n
using namespace std;\n
\n
int row = 3, col = 4;\n
int matrix[3][4] = {{1,2,3,4},{11,21,31,41},\n{12,22,32,42}};\n
\n
void transpose()\n
{\n
    int temp;\n
\n
        for(int i=0;i&lt;row;i++)\n
    {\n
        for(int j=i;j&lt;col;j++)\n
        {\n
            temp = matrix[i][j];\n
            matrix[i][j] = matrix[j][i];\n
            matrix[j][i] = temp;\n
        }\n
    }\n
\n
    temp = col;\n
    col = row;\n
    row = temp;\n
}\n
\n
void display()\n
{\n
    for(int i=0;i&lt;row;i++)\n
    {\n
        for(int j=0;j&lt;col;j++)\n
        {\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";\n
        }\n
\n
        cout&lt;&lt;endl;\n
    }\n
}\n
\n
int main()\n
{\n
    cout&lt;&lt;\"MATRIX : \"&lt;&lt;endl;\n
    display();\n
\n
    transpose();\n
\n
    cout"&lt;&lt;""TRANSPOSE MATRIX : ""&lt;&lt;endl;\n
    display();\n
\n
    return 0;\n
}\n

</string>
    <string name="transpose_heading">Transpose of a Matrix</string>
    <string name="codezigzag">

#include&lt;iostream&gt;	\n
#include&lt;vector&gt;												\n
												\n
using namespace std;												\n
												\n
vector&lt;vector&lt;int&gt;&gt; matrix {{1,2,3,4,5},\n{6,7,8,9,10},{11,12,13,14,15},\n{16,17,18,19,20},{21,22,23,24,25}};	\n
												\n
void display()												\n
{												\n
    for(int i=0;i&lt;matrix.size();i+=1)						\n
    {												\n
        for(int j=0;j&lt;matrix[0].size();j+=1)					\n
        {												\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\t\";				\n
        }												\n
        cout&lt;&lt;endl;												\n
    }												\n
}												\n
												\n
int main()												\n
{												\n
    int j = 0;												\n
												\n
    display();												\n
												\n
    cout&lt;&lt;endl&lt;&lt;endl;							\n
												\n
    for(int i=0;i&lt;matrix.size();i+=1)					\n
    {												\n
        if(i%2 == 0)												\n
        {												\n
            for(int j=0;j&lt;matrix[0].size();j+=1)							\n
            {												\n
                cout&lt;&lt;matrix[i][j]&lt;&lt;\" \";							\n
            }												\n
        }												\n
												\n
        else												\n
        {												\n
            for(int j=matrix[0].size()-1;j>=0;j-=1)								\n
            {												\n
                cout&lt;&lt;matrix[i][j]&lt;&lt;\" \";				\n
            }												\n
        }												\n
												\n
    }												\n
												\n
    return 0;												\n
}												\n
												\n
</string>
    <string name="ZigZag_heading">Zig Zag Traversal</string>
    <string name="Spiral_heading">Print Spiral</string>
    <string name="Spiralcode">
        
#include&lt;iostream&gt;				\n
#include&lt;vector&gt;												\n
												\n
using namespace std;												\n
												\n
vector&lt;vector&lt;int>> matrix {{1,2,3,4,5},\n{11,21,31,41,51},{12,22,32,42,52},{121,222,323,425,452},{10,20,30,40,50}};		\n
												\n
void transpose()												\n
{												\n
    int temp;												\n
												\n
    for(int i=0;i&lt;matrix.size();i++)				\n
    {												\n
        for(int j=i;j&lt;matrix[0].size();j++)							\n
        {												\n
            temp = matrix[i][j];					\n
            matrix[i][j] = matrix[j][i];					\n
            matrix[j][i] = temp;					\n
        }												\n
    }												\n
												\n
}												\n
												\n
void display()												\n
{												\n
    for(int i=0;i&lt;matrix.size();i++)						\n
    {												\n
        for(int j=0;j&lt;matrix[0].size();j++)			\n
        {												\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";							\n
        }												\n
        cout&lt;&lt;endl;												\n
    }												\n
}												\n
												\n
void rotate90()												\n
{												\n
    int temp;												\n
												\n
    transpose();												\n
												\n
    for(int i=0;i&lt;matrix.size();i++)												\n
    {												\n
        for(int j=0;j&lt;matrix[0].size()/2;j++)				\n
        {												\n
            temp = matrix[i][j];												\n
            matrix[i][j] = matrix[i][matrix[0].size() - j - 1];				\n
            matrix[i][matrix[0].size() - j - 1] = temp;			\n
        }												\n
    }												\n
												\n
}												\n
												\n
void printLine()												\n
{												\n
    for(int i=0;i&lt;matrix[0].size()-1;i++)							\n
    {												\n
        cout&lt;&lt;matrix[0][i]&lt;&lt;" -> ";							\n
    }												\n
												\n
    for(int i=0;i&lt;matrix.size();i++)								\n
    {												\n
        cout&lt;&lt;matrix[i][matrix[i].size()-1]&lt;&lt;\" -> \";						\n
        matrix[i].erase(matrix[i].begin() + matrix[i].size()-1, matrix[i].begin() + matrix[i].size());		\n
    }												\n
												\n
    matrix.erase(matrix.begin(), matrix.begin() + 1);							\n
												\n
}												\n
												\n
int main()												\n
{												\n
    cout&lt;&lt;\"MATRIX : \"&lt;&lt;endl;												\n
    display();												\n
												\n
    cout&lt;&lt;endl&lt;&lt;\"SPIRAL PRINTING : \"&lt;&lt;endl;					\n
												\n
    while(matrix.size() != 0)												\n
    {												\n
        printLine();												\n
        rotate90();												\n
        rotate90();												\n
    }												\n
												\n
    return 0;												\n
}												\n
												\n
        
    </string>

    <string name="antiSpiral_Heading">Printing Anti-Spiral</string>
    <string name="antiSpiralcode">

#include&lt;iostream&gt;										\n
#include&lt;vector&gt;										\n
#include&lt;stack&gt;										\n
										\n
using namespace std;										\n
										\n
vector&lt;vector&lt;int&gt;&gt; matrix {{1,2,3,4,5},\n{6,7,8,9,10},{11,12,13,14,15},{16,17,18,19,20},{21,22,23,24,25}};\n	\n
stack &lt;int&gt; stackSpiral;				\n
										\n
void transpose()										\n
{										\n
    int temp;										\n
										\n
    for(int i=0;i&lt;matrix.size();i++)					\n
    {										\n
        for(int j=i;j&lt;matrix[0].size();j++)					\n
        {										\n
            temp = matrix[i][j];						\n
            matrix[i][j] = matrix[j][i];				\n
            matrix[j][i] = temp;			\n
        }										\n
    }										\n
										\n
}										\n
										\n
void display()										\n
{										\n
    for(int i=0;i&lt;matrix.size();i++)							\n
    {										\n
        for(int j=0;j&lt;matrix[0].size();j++)						\n
        {										\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";							\n
        }										\n
        cout&lt;&lt;endl;							\n
    }										\n
}										\n
										\n
void rotate90()										\n
{										\n
    int temp;										\n
										\n
    transpose();										\n
										\n
    for(int i=0;i&lt;matrix.size();i++)							\n
    {										\n
        for(int j=0;j&lt;matrix[0].size()/2;j++)							\n
        {										\n
            temp = matrix[i][j];								\n
            matrix[i][j] = matrix[i][matrix[0].size() - j - 1];							\n
            matrix[i][matrix[0].size() - j - 1] = temp;								\n
        }										\n
    }										\n
										\n
}										\n
										\n
void printLine()										\n
{										\n
    for(int i=0;i&lt;matrix[0].size()-1;i++)										\n
    {										\n
        stackSpiral.push(matrix[0][i]);										\n
    }										\n
										\n
    for(int i=0;i&lt;matrix.size();i++)										\n
    {										\n
        stackSpiral.push(matrix[i][matrix[i].size()-1]);										\n
        matrix[i].erase(matrix[i].begin() + matrix[i].size()-1, matrix[i].begin() + matrix[i].size());		\n
    }										\n
										\n
    matrix.erase(matrix.begin(), matrix.begin() + 1);										\n
										\n
}										\n
										\n
int main()										\n
{										\n
    cout&lt;&lt;\"MATRIX : \"&lt;&lt;endl;										\n
    display();										\n
										\n
    cout&lt;&lt;endl&lt;&lt;\"SPIRAL PRINTING : \"&lt;&lt;endl;									\n
										\n
    while(matrix.size() != 0)										\n
    {										\n
        printLine();										\n
        rotate90();										\n
        rotate90();										\n
    }										\n
										\n
    cout&lt;&lt;endl;										\n
										\n
    while(stackSpiral.empty()!= true)										\n
    {										\n
        cout&lt;&lt;stackSpiral.top()&lt;&lt;\" -> \";									\n
        stackSpiral.pop();										\n
    }										\n
										\n
    return 0;										\n
}										\n
										\n

    </string>

    <string name="rotate_heading">Rotate Matrix</string>
    <string name="rotatecode">

#include&lt;iostream&gt;								\n
#include&lt;vector&gt;								\n
								\n
using namespace std;								\n
								\n
int row = 4, col = 5;								\n
int matrix[4][5] = {{1,2,3,4,5},{11,21,31,41,51},{12,22,32,42,52},{121,222,323,425,452},};		\n
								\n
void transpose()								\n
{								\n
    int temp;								\n
								\n
    for(int i=0;i&lt;row;i++)								\n
    {								\n
        for(int j=i;j&lt;col;j++)								\n
        {								\n
            temp = matrix[i][j];								\n
            matrix[i][j] = matrix[j][i];								\n
            matrix[j][i] = temp;								\n
        }								\n
    }								\n
								\n
    temp = col;								\n
    col = row;								\n
    row = temp;								\n
}								\n
								\n
void display()								\n
{								\n
    for(int i=0;i&lt;row;i++)								\n
    {								\n
        for(int j=0;j&lt;col;j++)								\n
        {								\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";								\n
        }								\n
								\n
        cout&lt;&lt;endl;								\n
    }								\n
}								\n
								\n
int main()								\n
{								\n
    int temp;								\n
    cout&lt;&lt;\"MATRIX : \"&lt;&lt;endl;							\n
    display();								\n
								\n
    transpose();								\n
								\n
    cout&lt;&lt;endl&lt;&lt;\"TRANSPOSE MATRIX : \"&lt;&lt;endl;							\n
    display();								\n
								\n
    for(int i=0;i&lt;row;i++)								\n
    {								\n
        for(int j=0;j&lt;col/2;j++)								\n
        {								\n
            temp = matrix[i][j];								\n
            matrix[i][j] = matrix[i][col - j - 1];								\n
            matrix[i][col - j - 1] = temp;								\n
        }								\n
    }								\n
								\n
    cout&lt;&lt;endl;								\n
    cout&lt;&lt;\"ROTATED MATRIX : \";								\n
    cout&lt;&lt;endl;								\n
								\n
    display();								\n
								\n
    return 0;								\n
}								\n


    </string>
    <string name="see_list_button">see list</string>
    <string name="try_random_button">try random</string>
    <string name="rotate_90_button">Rotate 90</string>
    <string name="anti_spiral_printing_button">Anti-Spiral Printing</string>
    <string name="spiral_printing_button">Spiral Printing</string>
    <string name="zig_zag_printing_button">Zig-Zag Printing</string>
    <string name="transpose_button">Transpose</string>
    <string name="back_button">Back</string>
    <string name="front_button">Next</string>
    <string name="button_2">Button</string>
    <string name="button_3">Z Printing</string>
    <string name="i_m_a_programmer_text">I\'m a PROGRAMMER…</string>
    <string name="i_want_learn_more_text">I\'m a LEARNER…</string>
    <string name="tell_us_who_you_are_heading">Who You Are</string>
    <string name="random_description">Try a random topic.</string>
    <string name="see_list">Choose a topic from the list of programmes.</string>
    <string name="choose_heading">Choose</string>
    <string name="coder_meta">[ ] : I\'m looking for codes and coding approaches for matrix related problems</string>
    <string name="nerd_meta">[ ] : I want to learn more about matrices and their applications</string>
    <string name="approach_button">Tell me the approach</string>
    <string name="rotateCode">

        The problem is to rotate a matrix by 90 degrees, similar to the problem of rotation of an image.

    </string>
    <string name="hint_code_button">Maybe, a hint will do !</string>
    <string name="hide_code_button">Hide Code</string>
    <string name="spiral_code">

        The problem is to print the matrix in spirally-traversed order.

    </string>
    <string name="code_zigzag">

        The problem is to print the matrix in zig-zag traversed order.

    </string>
    <string name="codeAntiSpiral">

        The problem is to print the matrix in the anti-spiral traversed order.

    </string>
    <string name="code_Transpose">

        The problem is to find the transpose of a matrix.

    </string>
    <string name="code_ZPrinting">

        The problem is to print the matrix in a Z-Traversed order.

    </string>
    <string name="z_printing_heading">Z-Printing</string>
    <string name="ZPcode">

#include&lt;iostream&gt;										\n
#include&lt;vector&gt;										\n
										\n
using namespace std;										\n
										\n
vector &lt;vector &lt;int&gt;&gt; matrix{{1,2,3,4,5},\n{6,7,8,9,10},{11,12,13,14,15},{16,17,18,19,20},\n{21,22,23,24,25}};	\n
										\n
int main()										\n
{										\n
    int i=0;										\n
    int j=-1;										\n\n
    int lastRow =\n matrix[ matrix.size() - 1 ].size() - 1;										\n
										\n
    /* You can however index the row with \'0\'\n as well since we consider square matrices */	\n
										\n
    for(int r=0; r&lt;matrix.size(); r++)										\n
    {										\n
        for(int c = 0; c&lt;matrix[0].size(); c++)										\n
        {										\n
            cout&lt;&lt;matrix[r][c]&lt;&lt;\"\\t\";										\n
        }										\n
        cout&lt;&lt;endl;										\n
    }										\n
    cout&lt;&lt;endl;										\n
										\n
										\n
    for(i=0;i&lt;matrix[0].size();i++)										\n
    {										\n
        cout&lt;&lt;matrix[0][i]&lt;&lt;\" \";										\n
    }										\n
										\n
    while(i>0)										\n
    {										\n
        cout&lt;&lt;matrix[j+=1][i-=1]&lt;&lt;\" \";										\n
    }										\n
										\n
    for(int c=1; c &lt; lastRow + 1 ; c++)										\n
    {										\n
        cout&lt;&lt;matrix[lastRow][c]&lt;&lt;\" \";										\n
    }										\n
										\n
    cout&lt;&lt;endl;										\n
										\n
    return 0;										\n
}										\n
										\n
    </string>
    <string name="back_button_random">I think I\'ll switch</string>
    <string name="welcome1">Hi, I\'ll get you acquainted with the setup</string>
    <string name="welcome2">Great to see you back again !</string>
    <string name="see_assistant_button">See Assistant</string>
    <string name="message_headertouch">{ } : And, you can move back to the previous page by clicking once in the header</string>

    <string name="majorswapheading">Swap Major Diagonal</string>
    <string name="majordiagonalprobelem">

        The problem is to swap the elements of the major diagonal.

    </string>
    <string name="majorcode">

#include&lt;iostream&gt;						\n
#include&lt;vector&gt;							\n
							\n
using namespace std;							\n
							\n
const int n = 4;							\n
int matrix[n][n];							\n
							\n
swapMajorDiagonal()							\n
{							\n
    int temp;							\n
							\n
    for(int i=0;i&lt;n/2;i++)							\n
    {							\n
        temp = matrix[i][i];							\n
        matrix[i][i] = matrix[n-i-1][n-i-1];							\n
        matrix[n-i-1][n-i-1] = temp;							\n
    }							\n
}							\n
							\n
void display()							\n
{							\n
							\n
    for(int i=0;i&lt;n;i++)							\n
    {							\n
        for(int j=0;j&lt;n;j++)							\n
        {							\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";							\n
        }							\n
        cout&lt;&lt;endl;							\n
    }							\n
							\n
    cout&lt;&lt;endl&lt;&lt;endl;							\n
							\n
}							\n
							\n
int main()							\n
{							\n
    int counter = 0;							\n
							\n
    for(int i=0;i&lt;n;i++)							\n
    {							\n
        for(int j=0;j&lt;n;j++)							\n
        {							\n
            matrix[i][j] = counter++;							\n
        }							\n
    }							\n
							\n
    /* Instead of counter you can also use ( n * i ) + j */							\n
							\n
    /* Since, the index is a linear combination of rows and columns */				\n
							\n
    /* For 3x3 matrix, index \'5\' comes in the row 1, column 2 */							\n
							\n
    /* 5 = ( n = 3 )*( i = 1 ) + ( j = 2 ) */							\n
							\n
    /* We do not do it here just for easier comprehension */							\n
							\n
    cout&lt;&lt;\"GIVEN MATRIX : \"&lt;&lt;endl&lt;&lt;endl;							\n
							\n
    display();							\n
							\n
    swapMajorDiagonal();							\n
							\n
    cout&lt;&lt;\"MAJOR DIAGONAL : \"&lt;&lt;endl&lt;&lt;endl;							\n
							\n
    display();							\n
							\n
    return 0;							\n
}							\n

    </string>

    <string name="minorswapheading">Swap Minor Diagonal</string>
    <string name="minordiagonalproblem">

        The problem is to swap the elements of the minor diagonal.

    </string>
    <string name="minorcode">

#include&lt;iostream&gt;							\n
#include&lt;vector&gt;						\n
							\n
using namespace std;							\n
							\n
const int n = 4;							\n
int matrix[n][n];							\n
							\n
swapMinorDiagonal()							\n
{							\n
    int temp;							\n
							\n
    for(int i=0;i&lt;n/2;i++)							\n
    {							\n
        temp = matrix[i][n-i-1];							\n
        matrix[i][n-i-1] = matrix[n-i-1][i];							\n
        matrix[n-i-1][i] = temp;							\n
    }							\n
}							\n
							\n
void display()							\n
{							\n
							\n
    for(int i=0;i&lt;n;i++)							\n
    {							\n
        for(int j=0;j&lt;n;j++)							\n
        {							\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";							\n
        }							\n
        cout&lt;&lt;endl;							\n
    }							\n
							\n
    cout&lt;&lt;endl&lt;&lt;endl;							\n
							\n
}							\n
							\n
int main()							\n
{							\n
    int counter = 0;							\n
							\n
    for(int i=0;i&lt;n;i++)							\n
    {							\n
        for(int j=0;j&lt;n;j++)							\n
        {							\n
            matrix[i][j] = counter++;							\n
        }							\n
    }							\n
							\n
    /* Instead of counter you can also use ( n * i ) + j */							\n
							\n
    /* Since, the index is a linear combination of rows and columns */							\n
							\n
    /* For 3x3 matrix, index \'5\' comes in the row 1, column 2 */							\n
							\n
    /* 5 = ( n = 3 )*( i = 1 ) + ( j = 2 ) */							\n
							\n
    /* We do not do it here just for easier comprehension */							\n
							\n
    cout&lt;&lt;\"GIVEN MATRIX \"&lt;&lt;endl&lt;&lt;endl;							\n
							\n
    display();							\n
							\n
    swapMinorDiagonal();							\n
							\n
    cout&lt;&lt;\"MINOR DIAGONAL : \"&lt;&lt;endl&lt;&lt;endl;							\n
							\n
    display();							\n
							\n
    return 0;							\n
}							\n
        
    </string>


    <string name="swapheading">Swap Diagonals</string>
    <string name="diagonalproblem">

        The problem is to swap the diagonals of a matrix.

    </string>
    <string name="swap_diagonals">

#include&lt;iostream&gt;							\n
#include&lt;vector&gt;							\n
							\n
using namespace std;							\n
							\n
const int n = 5;							\n
int matrix[n][n];							\n
							\n
swapDiagonal()							\n
{							\n
    int temp;							\n
							\n
    for(int i=0;i&lt;n;i++)							\n
    {							\n
        temp = matrix[i][n-i-1];							\n
        matrix[i][n-i-1] = matrix[i][i];							\n
        matrix[i][i] = temp;							\n
    }							\n
}							\n
							\n
void display()							\n
{							\n
							\n
    for(int i=0;i&lt;n;i++)							\n
    {							\n
        for(int j=0;j&lt;n;j++)							\n
        {							\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";							\n
        }							\n
        cout&lt;&lt;endl;							\n
    }							\n
							\n
    cout&lt;&lt;endl&lt;&lt;endl;							\n
							\n
}							\n
							\n
int main()							\n
{							\n
    int counter = 0;							\n
							\n
    for(int i=0;i&lt;n;i++)							\n
    {							\n
        for(int j=0;j&lt;n;j++)							\n
        {							\n
            matrix[i][j] = counter++;							\n
        }							\n
    }							\n
							\n
    /* Instead of counter you can also use ( n * i ) + j */							\n
							\n
    /* Since, the index is a linear combination of rows and columns */							\n
							\n
    /* For 3x3 matrix, index \'5\' comes in the row 1, column 2 */							\n
							\n
    /* 5 = ( n = 3 )*( i = 1 ) + ( j = 2 ) */							\n
							\n
    /* We do not do it here just for easier comprehension */							\n
							\n
    cout&lt;&lt;"GIVEN MATRIX "&lt;&lt;endl&lt;&lt;endl;							\n
							\n
    display();							\n
							\n
    swapDiagonal();							\n
							\n
    cout&lt;&lt;\"SWAPPING DIAGONALS : \"&lt;&lt;endl&lt;&lt;endl;							\n
							\n
    display();							\n
							\n
    return 0;							\n
}							\n
							\n
    </string>

    <string name="oddmagicsquareheading">Odd Magic Square</string>
    <string name="problemoddmagicsquare">


        To find the magic square of any odd order.\n
        \n
        A <b>Magic Square</b> is a matrix of which the sum of the elements of the row, the column, and the diagonals,
        all sum up to the same value.


    </string>
    <string name="oddmagicsquarecode">

        #include&lt;iostream&lt;		\n
#include&lt;vector&gt;					\n
					\n
using namespace std;					\n
					\n
const int n=5;					\n
int magicSquare[n][n];					\n
					\n
void display()					\n
{					\n
					\n
    for(int i=0;i&lt;n;i++)					\n
    {					\n
        for(int j=0;j&lt;n;j++)					\n
        {					\n
            cout&lt;&lt;magicSquare[i][j]&lt;&lt;\"\\t\";		\n
        }					\n
        cout&lt;&lt;endl;					\n
    }					\n
					\n
}					\n
					\n
int main()					\n
{					\n
    int counter = 1;					\n
    int row = n/2;					\n
    int col = n-1;					\n
					\n
    magicSquare[row][col] = counter;			\n
					\n
    while(true)					\n
    {					\n
        row -= 1;					\n
        col += 1;					\n
					\n
        if(row == -1 &amp;&amp; col == n)		\n
        {					\n
            row = 0;					\n
            col = n-2;					\n
        }					\n
					\n
        else if(row == -1)					\n
        {					\n
            row = n-1;					\n
        }					\n
					\n
        else if(col == n)					\n
        {					\n
            col = 0;					\n
        }					\n
					\n
        else if(magicSquare[row][col] != 0)			\n
        {					\n
            col -=2;					\n
            row += 1;					\n
        }					\n
					\n
        counter++;					\n
					\n
        if(counter&gt;n*n)					\n
        {					\n
            break;					\n
        }					\n
					\n
        magicSquare[row][col] = counter;					\n
					\n
    }					\n
					\n
    display();					\n
    cout&lt;&lt;endl;					\n
					\n
    return 0;					\n
}					\n
					\n

    </string>

    <string name="maxSumPathNCHeading">Maximum Sum Path</string>
    <string name="problemMaxSumPathNC">Finding the maximum sum path</string>
    <string name="maxSumPathNCcode">

#include&lt;iostream&gt;										\n
#include&lt;vector&gt;										\n
										\n
using namespace std;										\n
										\n
vector &lt;vector &lt;int&gt;&gt; pathMatrix {{12,3,45,2,56},{132,2,8,6,0},{2,67,0,11,9},{42,7,10,1,19},{20,6,8,14,123}};										\n
										\n
vector &lt;int&gt; maximumWeightPath;										\n
										\n
void printMatrix()										\n
{										\n
    for(int i=0;i&lt;pathMatrix.size();i++)										\n
    {										\n
        for(int j=0;j&lt;pathMatrix[i].size();j++)										\n
        {										\n
            cout&lt;&lt;pathMatrix[i][j]&lt;&lt;\" \";										\n
        }										\n
        cout&lt;&lt;endl;										\n
    }										\n
										\n
    cout&lt;&lt;endl&lt;&lt;endl;										\n
}										\n
										\n
void printPath()										\n
{										\n
    int pathWeight = 0;										\n
										\n
    cout&lt;&lt;\"START -&gt; \";										\n
										\n
    for(int i=0;i&lt;maximumWeightPath.size();i++)										\n
    {										\n
        cout&lt;&lt;maximumWeightPath[i]&lt;&lt;\" -&gt; \";										\n
        pathWeight += maximumWeightPath[i];										\n
    }										\n
										\n
    cout&lt;&lt;\"END\";										\n
										\n
    cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;\"MAXIMUM PATH WEIGHT : \"&lt;&lt;pathWeight;										\n
}										\n
										\n
int main()										\n
{										\n
    int maximumWeight = 0;										\n
										\n
    printMatrix();										\n
										\n
    for(int i=0;i&lt;pathMatrix.size();i++)										\n
    {										\n
        maximumWeight = 0;										\n
										\n
        for(int j=0;j&lt;pathMatrix[i].size();j++)										\n
        {										\n
            if(maximumWeight&lt;pathMatrix[i][j])										\n
            {										\n
                maximumWeight = pathMatrix[i][j];										\n
            }										\n
        }										\n
										\n
        maximumWeightPath.push_back(maximumWeight);										\n
										\n
    }										\n
										\n
    printPath();										\n
										\n
    return 0;										\n
}										\n
										\n
        
    </string>

    <string name="stochastic_matrix_heading">Stochastic Matrix</string>
    <string name="stochastic_matrix_problem">

        The problem is to check whether a given matrix is a Stochastic Matrix. \n
        \n
        A Stochastic Matrix has to be \n
        \n
        1. A positive real-valued matrix,\n
        2. \n\n\n\n\n\n
        234234413\\n\n\n\n\n\n\n\n\\n\n\n\n\n456456

    </string>
    <string name="stochastic_matrix_code">

#include&lt;iostream&gt;								\n
#include&lt;vector&gt;								\n
								\n
using namespace std;								\n
								\n
vector &lt;vector &lt;float&gt;&gt; matrix {{1,0,0},{0.1,0.4,0.5},{0,0.1,0.9}};								\n
								\n
void displayMatrix()								\n
{								\n
    for(int i=0;i&lt;matrix.size();i++)								\n
    {								\n
        for(int j=0;j&lt;matrix[i].size();j++)								\n
        {								\n
            cout&lt;&lt;matrix[i][j]&lt;&lt;\"\\t\";								\n
        }								\n
        cout&lt;&lt;endl;								\n
    }								\n
    cout&lt;&lt;endl&lt;&lt;endl;								\n
}								\n
								\n
int main()								\n
{								\n
    bool isRight = true;								\n
    int sum = 0;								\n
								\n
    displayMatrix();								\n
								\n
								\n
    for(int i=0; i&lt;matrix.size(); i++)								\n
    {								\n
        sum = 0;								\n
								\n
        /* Has to be a square matrix */								\n
								\n
         if(matrix.size() != matrix[i].size())								\n
            {								\n
                isRight = false;								\n
                break;								\n
            }								\n
								\n
         /* Sum has to be a  one, values non-negative and not greater than one */								\n
								\n
								\n
        for(int j=0; j&lt;matrix[i].size(); j++)								\n
        {								\n
            if(matrix[i][j] &lt; 0 || matrix[i][j] &gt; 1)								\n
            {								\n
                isRight = false;								\n
                break;								\n
            }								\n
								\n
            sum += matrix[i][j];								\n
        }								\n
								\n
        if(sum != 1)								\n
        {								\n
            isRight = false;								\n
            break;								\n
        }								\n
								\n
        if(isRight == false)								\n
        {								\n
            break;								\n
        }								\n
								\n
    }								\n
								\n
    if(isRight == true)								\n
    {								\n
        cout&lt;&lt;\"IS A RIGHT STOCHASTIC MATRIX\";								\n
    }								\n
    else								\n
    {								\n
        cout&lt;&lt;\"NOT A RIGHT STOCHASTIC MATRIX\";								\n
    }								\n
								\n
    return 0;								\n
}								\n

    </string>

    <string name="stochastic_content">

        The \'<b>Stochastic Matrix</b>\' otherwise called the <b>Probability Matrix</b> or the <b>Markov Matrix</b>,
        is one which has non-negative real valued entries.\n
        \n
        Based on the sum, these matrices may be classified into three : \n
        \n
        1. Right Stochastic Matrix ( <i>Row-wise sum == 1</i> )\n\n
        2. Left Stochastic Matrix ( <i>Column-wise sum == 1</i> )\n\n
        3. Doubly Stochastic Matrix ( <i>Row-wise sum == 1 and column-wise sum == 1</i> )\n\n
        \n
        As the name suggests, the entries of the matrix, are probabilities, hence they have to
        be in the range [0 - 1], inclusive.\n
        \n
        \n
        <b>Extra :</b>\n
        \n
        1. According to the <b>Sinkhorn\'s Theorem</b>, any matrix with strictly positive values can
        be made Doubly Stochastic by pre- and post- multiplication with diagonal matrices.\n
        \n
        2. The product of two Doubly Stochastic matrices is again a Doubly Stochastic matrix.\n

    </string>

    <string name="hessenberg_heading">Hessenberg Matrix</string>
    <string name="hessenberg_content">

        The <b>Hessenberg Matrix</b> is one which has zeroes as its elements above its first
        super-diagonal or below its first sub-diagonal. It is a square-matrix, that is almost triangular.\n
        \n
        In the case of zeroes below the first sub-diagonal, the matrix is named an <b>upper-hessenberg matrix</b>,
        and in the other case it is called a <b>lower-hessenberg matrix</b>.\n
        \n
        \n
        <b>Why is this important ?</b>\n
        \n
        Linear Algebra algorithms require less computational effort when they are applied to triangular matrices.
        This is extended to Hessenberg Matrices as well which is an almost-triangular matrix.\n
        \n
        If it is found difficult to convert a general matrix into a triangular-matrix, conversion to a
        Hessenberg Matrix is the next idea thought of.\n
        \n
        A general matrix may be converted to a Hessenberg Matrix using say, the Householder\'s Transformation,
        in a finite number of steps. This can be further reduced to a triangular matrix through
        Shifted QR-Factorisation, or other iterative procedures.
        \n

    </string>

    <string name="idempotent_matrix_button">Idempotent Matrix</string>
    <string name="idempotent_content">

        We might remember of the idempotent law we\'ve used in set theory, or boolean algebra or in any other field.
        Well, if you did not, no issues, here is the definition.\n
        \n
        Mathematically,\n
        \n
        If \'A\' is a matrix, the A<sup><small>2</small></sup> = A\n
        \n
        This can be extended to A<sup><small>n</small></sup> = A, by induction.\n
        \n
        That is, if the matrix is multiplied with itself, then the product turns out to be the same matrix.\n
        \n
        One immediate point we can make after this statement is that, the matrix to be idempotent has to
        necessarily be a square matrix.\n
        \n
        Wait, but why?\n
        \n
        We know that for multiplication of matrices to be defined, the order of the matrices have to be
        \'m * n\' and \'n * p\' in the general case. Here, since we multiply the same matrix with itself, \'m\' has to
        be equal to \'n\'.
        \n
        <b>Properties : </b>\n
        \n
        1. The matrix is always diagonalisable, and has eigenvalues \'0\' or \'1\'.\n
        2. The trace of the matrix is equal to the rank of the matrix.\n
        3. The trace is hence always an integer.\n
        4. Identity matrix is the only non-singular idempotent matrix.\n
        \n


    </string>

    <string name="singularmatrix_button">Singular Matrix</string>
    <string name="singularmatrix_content">

        A matrix is said to be singular if the determinant of the matrix is \'0\'. Hence, by this argument,
        we can say that singular matrices do not have definable inverses.\n
        \n
        We can also informally state that,\n
        \n
         1. If all the elements in a row or column of the matrix is zero, then it is a singular matrix.\n
         2. If two or more rows or columns of a matrix are the same, then again the matrix is singular.\n
        \n
        Hence, we can say that a matrix with non-zero determinant value is a non-singular matrix.\n
        \n
        Now, why is it called \'Singular\'\n
        \n
        The determinant value stands for the value by which the system is scaled. Hence, when this value diminishes to zero,
        this means that the system squishes to a lower dimension. This concept may be used to define the
        relevance of the word \'singularity\' in this context.\n
        \n
        It is perfectly fine if you don\'t get this in the first time. Do read the intuitive idea behind matrix multiplication
        and have a read again.

    </string>

    <string name="involutory_matrix_button">Involutory Matrix</string>
    <string name="involutory_content">

        The <b>Involutory Matrix</b> has its inverse equal to itself, hence the name. In other words,
        let there be a matrix \'A\', then, A = A<sup><small>-1</small></sup> A sup&gt;\n
        \n
        or\n
        \n
        A<sup><small>2</small></sup> = I\n
        \n
        An involutory matrix which is also symmetric is orthogonal. In other words,\n
        \n
        Involutory Matrix + Symmetric Matrix =&gt; Orthogonal Matrix\n
        \n
        <b>Propreties : </b>\n
        \n
        Let \'A\' be an involutory matrix, then,\n
        \n
        1. Determinant of \'A\' = +1 or -1\n
        2. \'A\' is involutory iff (1/2)*( A + I ) is idempotent\n
        3. All powers of \'A\' are involutory, if power is odd - the result is \'A\' and \'I\' if power is even.\n
        \n

    </string>

    <string name="elementary_matrix_button">Elementary Matrix</string>
    <string name="elementary_content">

        An <b>Elementary Matrix</b> is one which differs from the identity matrix by a single elementary
        operation.\n
        \n
        What are <b>elementary row operations</b> ?\n
        \n
        There are three types of elementary operations, they are :\n
        \n
        1. Row-interchange\n
        \n
        R<sub><small>i</small></sub> &lt;-&gt; R<sub><small>j</small></sub>\n
        2. Row multiplied by a non-zero scalar value ( say, \'k\')\n
        \n
        R<sub><small>i</small></sub> &lt;-&gt; k *R<sub><small>i</small></sub>\n
        \n
        3. Row added by a scalar multiplied with another row.
        R<sub><small>i</small></sub> &lt;-&gt; R<sub><small>i</small></sub> + k * R<sub><small>j</small></sub>\n
        \n
        An interesting property is that the row-interchanged elementary matrix has a determinant value
        equal to the negative of that of the identity matrix.\n
        \n
        An interesting property is that the row-multiplied-by-scalar elementary matrix has a determinant value
        equal to \'k\' times of that of the identity matrix. The inverse of this matrix is \'1/k\' in the
        \'ith\' position where the multiplication was made.\n
        \n
        The interesting property of the third type is that the matrix and it\'s inverse are triangular matrices, and
        the determinant value is \'1\'.\n
        \n

    </string>

    <string name="frobenius_matrix_button">Frobenius Matrix</string>
    <string name="frobenius_content">

        The <b>Frobenius Matrix</b> is one which has all \'1\'s in the diagonal and arbitrary values in one column below
        the main diagonal. All the other entries are \'0\'.\n
        \n
        The Frobenius Matrix is invertible and the inverse of the Frobenius Matrix is the same matrix with
        changed signs <b>outside the main diagonal</b>.\n
        \n

    </string>

    <string name="orthogonal_matrix_button">Orthogonal Matrix</string>
    <string name="orthogonal_content">hi</string>

    <string name="binary_matrix_button">Binary Matrix</string>
    <string name="binary_content">

        A <b>Binary Matrix</b> is one which only has either of the two entries \'0\' or \'1\'.

    </string>

    <string name="sparse_matrix_button">Sparse Matrix</string>
    <string name="sparse_content">

        A <b>Sparse Matrix</b> is one which has fewer connections amongst all possible connections. The opposite of
        this type is the dense matrix which has more number of connections when compared to the total number of connections.
    </string>


    <string name="switchNerd">Check out theoritcal content under \'Learner\'. Just click switch at the top of this screen</string>

    <string name="adjoint_matrix_button">Adjoint Matrix</string>
    <string name="adjoint_content">

        The <b>Adjoint</b> or the <b>Adjugate</b> of a matrix is defined as the transpose of the Co-factor matrix.

    </string>

    <string name="cofactor_matrix_button">Cofactor Matrix</string>
    <string name="cofactor_content">

        The <b>Cofactor</b> of a matrix is defined as the Co-factor matrix.



    </string>


    <string name="signature_matrix_button">Signature Matrix</string>
    <string name="signature_matrix_content">

        <b>Note :</b> The following description is for <b>Signature Matrix</b>, and <b>not Signature of a Matrix</b>.\n
        \n
        This is a diagonal matrix with diagonal elements being plus or minus \'1\'.
        The matrix in these cases is the same as their inverse. Here, all of the diagonal elements may not necessarily be the same.\n
        \n
        Hence, these matrices are an example of involutory matrices. Since these matrices are symmetric as well, these matrices
        are Orthogonal as well.\n
        \n
        These matrices represent a reflection in each of the axes corresponding to the negated rows or columns.\n
        \n

    </string>


    <string name="trace_matrix_button">Trace of Matrix</string>
    <string name="trace_matrix_content">

        The <b>Trace of a matrix</b> is the sum of the elements of the principal diagonal, where the principal diagonal
        refers to the elements of the matrix having the same row and column index.

    </string>

    <string name="matrixsum_button">Sum of Matrices</string>
    <string name="matrixsum_content">

        The following points must be kept in mind while carrying out the addition of matrices.\n
        \n
        1. The <b>order</b> of both the matrices have to be the <b>same</b>.\n
        \n
        2. The summation of matrices is carried out such that the element in the resultant matrix,
        is formed by the summation of the elements in the corresponding indices of the matrices being added.\n
        \n
        i.e. Let the matrices \'A\' and \'B\' be added in oder to form a matrix \'C\'. Then, the
        order of matrices \'A\', \'B\' and \'C\' are the same.\n
        \n
        And, the sum of the element in the index ( i, j ) of matrix \'A\' is added with that of \'B\' to
        produce the element in the ( i, j ) index of the matrix \'C\'.\n
        \n
        3. Addition of matrices is also commutative.\n\ni.e. A + B = B + A\n
        \n

    </string>

    <string name="sum_dets_button">Sum of Determinants</string>
    <string name="sum_dets_content">

        The sum of determinants may be performed by adding the corresponding elements of a row of the determinants,
        keeping other rows the same.

    </string>

    <string name="symmetricMatrix_button">Symmetric Matrix</string>
    <string name="symmetricMatrix_content">

        A <b>Symmetric Matrix</b> is any matrix, which is the same even after taking the transpose.\n
        \n
        Mathematically,\n
        \n
        If \'A\' is a matrix, then, A == transpose( A ).\n
        \n
        In other words, we can even say that the matrix has a mirror as its diagonal.\n
        \n
        Some interesting points regarding Symmetric Matrices :\n
        \n
        1. If the Symmetric Matrix is Orthogonal, then the square of the matrix is an Identity Matrix.
        Hence, the determinant of the matrix will be \'1\'.\n
        \n
        2. For a symmetric matrix, the eigen vectors corresponding to the unequal eigenvalues are orthogonal.
        i.e. say, \'X\' and \'Y\' are two eigen vectors corresponding to the unequal eigenvalues, then X(T) * Y = 0.
        Or in other words, the inner product is \'0\'.\n

    </string>

    <string name="skewsymmetricMatrix_button">Skew-Symmetric Matrix</string>
    <string name="skewsymmetricMatrix_content">

        A <b>Skew-Symmetric Matrix</b> is any matrix, which is equal to the negative of it\'s transpose.\n
        \n
        Mathematically,\n
        \n
        If \'A\' is a matrix, then, A == (-1) * transpose( A ).\n
        \n
        In other words, we can even say that the matrix has a mirror as its diagonal.\n
        \n
        Some interesting points regarding Skew-Symmetric Matrices :\n
        \n
        1. If the Symmetric Matrix is Orthogonal, then the square of the matrix is \'-1\' times the Identity Matrix.
        Hence, the determinant of the matrix will be \'-1\'.\n
        \n
        2. The diagonal entries of such a matrix is necessarily \'0\'. Hence, the trace of the matrix os \'0\'.

    </string>

    <string name="matrices_intution_heading">Matrices : Intuition</string>
    <string name="matrix_intution_content">

        The <b>Matrix</b> is simply an arrangement of numbers, usually enclosed in rounded or square brackets.
        These are expressed in m * n form, where, \'m\' represents the number of rows and \'n\' represents the
        number of columns. This is defined as the order of the matrix.\n
        \n
        i.e. A matrix with \'m\' rows and \'n\' columns is defined as a matrix of order m * n ( <i>m by n</i> ).\n
        \n
        Understanding <b>\'order\'</b> is important in order the do operations in matrices these come to use.
        Some proofs may be greatly simplified using their orders.\n
        \n


    </string>

    <string name="determinants_intution_heading">Determinants : Intuition</string>
    <string name="det_intution_content">

        In order to define the intuitive idea behind determinants let us take the example of a 2x2 matrices and
        3x3 matrices.\n
        \n
        As we know, a matrix represents a transformation of a system of vectors. In the case of a 2x2 matrix, this represents
        a transformation in the 2-dimensional system, whereas a 3x3 matrix in a 3-dimensional system.\n
        \n
        The scale by which the matrix causes a transformation to the system is determined by the determinant.\n
        \n
        <b>Some Special Cases</b>\n
        \n
        1. A determinant value = 2, would be a scaling of the system by 2 times.
        2. A determinant value = 1, would mean that the system is neither enlarged nor shrunk.
        3. A determinant value = 0, this is interesting, as in this case it would mean that the system is shrunk to
        such a scale that the system squishes by a dimension.\n
        \n
        This would mean that a 3-dimensional system squishes to a 2-dimensional system, that is, into a line.

    </string>

    <string name="multiplying_matrices_heading">Multiplying Matrices</string>
    <string name="mult_matrix_content">

        <b>Matrix Multiplication</b> is often learnt the rote way. Well there is a fascinating intuitive idea behind
        this very concept. Before we move into multiplication, we have to know that matrices are an arrangement of numbers,
        geometrically, arrangement of vectors.\n
        \n
        When matrices are multiplied, say matrix \'B\' multiplied to matrix \'A\' ( A * B ), what we do is a transformation,
        on the matrix \'A\'.\n
        \n
        This sort of explains why matrix multiplication is not always commutative and matrix is required to have
        certain unique properties in order to be commutative.\n
        \n
        The scale by which the transformation is caused, that is, by how many times the system is enlarged or shrunk is defined
        by the determinant of the matrix, here, by the determinant o the matrix \'B\'.

    </string>

    <string name="multiplying_determinants_heading">Multiplying Determinants</string>
    <string name="mult_dets_content">



    </string>

    <string name="diagonalisation_heading">Diagonalisation of Matrices</string>
    <string name="diagonalisation_content">

        An matrix may be reduced to the diagonal form, or in other words, <b>diagonalised</b>. Mathematically,
        it can be said that any matrix \'A\' can be reduced to a diagonal matrix \'D\', by applying a transformation, \n
        \n
        <b>P(-1) * A * P = D</b>\n
        \n
        If there exists an Invertible matrix \'P\'. \'P\' is the collection of eigen vectors corresponding to
        each eigen value. The matrix \'P\' is called the \'Model Matrix\'. \n
        \n
        This would mean that the matrix of order \'n\' has \'n\' linearly independent eigen vectors, otherwise the determinant
        of the matrix \'P\' would be \'0\' hence, the matrix would not be invertible.
        \n
        The resulting diagonal matrix has its element as the eigen values of the matrix \'A\', and is called
        the \'Spectral Matrix\'.\n
        \n
        The above transformation is called the \'Similarity Transformation\'.


    </string>

    <string name="eigenvalue_heading">Eigenvalue</string>
    <string name="eigenvalue_content">

    Before we move on to know more about eigenvalues, we are to have an understanding about eigen vectors.\n
        \n
        Mathematically, it may be represented as a vector multiplied to some other matrix yielding the same
        vector scaled by some scalar quantity. This scalar quantity being the eigenvalue of the matrix.\n
        \n
        Eigen vectors are vectors that do not undergo any other change by a scaling, on applying a transformation.\n
        \n
        A normalised eigen vector is an eigen vector divided by the square root of the sum of the squares of the
        elements in the eigen vector.\n
        \n

    </string>
    <string name="calculations_button">CALCULATION</string>
    <string name="intution_button">INTUITION</string>
    <string name="types_of_matrices_button">TYPES</string>

    <string name="rank_button">Rank of a matrix</string>
    <string name="rank_content">

        The <b>Rank of a matrix</b> is the number of dimensions in the output of a transformation. If a 3-Dimensional
        system squishes to a plane, the rank is said to be 2.

    </string>
    <string name="progress_button">Progress</string>

</resources>
